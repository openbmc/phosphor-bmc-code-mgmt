{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8552e864_2d3dc2d5",
        "filename": "cpld/lattice/lattice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2025-06-13T18:07:01Z",
      "side": 1,
      "message": "I think we are working around this warning issue a lot. So this is what i would suggest -\n\n1. Change the sendReceive API in i2c.cpp to have a check for readData pointer as well alongwith readSize (https://github.com/openbmc/phosphor-bmc-code-mgmt/blob/master/common/i2c/i2c.cpp#L61) as that might be the reason for the warning (as readData is separate from readSize). See, if it fixes the problem.\n2. If #1 doesn\u0027t work then lets introduce a new API as you had in the beginning to use in CPLD updater. In a followup patch you can update the VR updater to use that too and drop the sendReceive API with primitive types. That way we don\u0027t have to do any of these work arounds.",
      "revId": "7c2e9d05601ccf57626cee73f14f19a7f343070d",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b3a9b69_fb3c5278",
        "filename": "cpld/lattice/lattice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1001939
      },
      "writtenOn": "2025-06-17T13:05:44Z",
      "side": 1,
      "message": "I believe the issue stems from the use of std::vector. Since vector is a non-trivial type — meaning it manages internal state and heap memory — creating it on the stack and then passing a reference into a coroutine introduces a potential lifetime issue. The coroutine may suspend and resume in a way that leads to accessing a reference to an already-invalidated stack frame.\n\nIn contrast, the original VR updater uses a fixed-size raw array (uint8_t rbuf[16]), which contains no heap pointers, virtual functions, or allocators. The compiler can recognize this pattern and often embeds such buffers directly into the coroutine frame, automatically managing their lifetime safely across suspension points.\n\nUsing std::make_unique moves the vector allocation to the heap, decoupling its lifetime from the stack and ensuring it remains valid throughout the coroutine\u0027s execution.\n\n1. \nFor the original (#1) API, no matter how I tried to modify it internally, the lifetime issue persisted because the vector was still tied to the stack.\n2. \nFor the new (#2) API, the logical solution seems to be shifting this responsibility to the caller side, rather than trying to encapsulate it entirely within the library API.\n\nSo I want to stick with the make_unique workaround, without making broader changes to the API structure.",
      "parentUuid": "8552e864_2d3dc2d5",
      "revId": "7c2e9d05601ccf57626cee73f14f19a7f343070d",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0d4bd23_35eb0f75",
        "filename": "cpld/lattice/lattice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2025-06-17T17:21:43Z",
      "side": 1,
      "message": "\u003e I believe the issue stems from the use of std::vector. Since vector is a non-trivial type — meaning it manages internal state and heap memory — creating it on the stack and then passing a reference into a coroutine introduces a potential lifetime issue. The coroutine may suspend and resume in a way that leads to accessing a reference to an already-invalidated stack frame.\n\u003e \n\u003e In contrast, the original VR updater uses a fixed-size raw array (uint8_t rbuf[16]), which contains no heap pointers, virtual functions, or allocators. The compiler can recognize this pattern and often embeds such buffers directly into the coroutine frame, automatically managing their lifetime safely across suspension points.\n\n\n@Daniel-Hsu@quantatw.com Then why don\u0027t we move to using fixed-size raw array to avoid all these workarounds? That code will be much cleaner in terms of readability and maintainability.",
      "parentUuid": "7b3a9b69_fb3c5278",
      "revId": "7c2e9d05601ccf57626cee73f14f19a7f343070d",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a3c21c9_1decdf3d",
        "filename": "cpld/lattice/lattice.cpp",
        "patchSetId": 1
      },
      "lineNbr": 708,
      "author": {
        "id": 1001939
      },
      "writtenOn": "2025-06-18T12:02:56Z",
      "side": 1,
      "message": "I ended up using #2.\n\n\u003e @Daniel-Hsu@quantatw.com Then why don\u0027t we move to using fixed-size raw array to avoid all these workarounds? That code will be much cleaner in terms of readability and maintainability.\n\nBecause the others are very similar to C++ code, and the previous CPLD updaters I referenced also used vector, I followed the same pattern and used vector as well. The root cause is still Clang\u0027s misjudgment.",
      "parentUuid": "e0d4bd23_35eb0f75",
      "revId": "7c2e9d05601ccf57626cee73f14f19a7f343070d",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}