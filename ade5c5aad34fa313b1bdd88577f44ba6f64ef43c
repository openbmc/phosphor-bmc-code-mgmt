{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "22f8e7b3_910d6edd",
        "filename": "test/common/software/software_association.cpp",
        "patchSetId": 9
      },
      "lineNbr": 120,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2025-10-16T17:15:13Z",
      "side": 1,
      "message": "@alexander.hansen@9elements.com Can you please check why you need this NOLINTNEXTLINE and create a followup patch to fix this if its an actual warning. We can discuss on this thread once you have a trace for this warning.\nFor now, i am merging this patch since all other comments have been resolved.",
      "revId": "ade5c5aad34fa313b1bdd88577f44ba6f64ef43c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e25ea43_5fee8702",
        "filename": "test/common/software/software_association.cpp",
        "patchSetId": 9
      },
      "lineNbr": 120,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-10-20T15:11:41Z",
      "side": 1,
      "message": "#### my nolint here was not required after all\n\nRaised https://gerrit.openbmc.org/c/openbmc/phosphor-bmc-code-mgmt/+/84538\nto drop the NOLINT.\n\nApparently it was not required, not sure if it\u0027s due to clang update or code restructuring in later revisions of this patch.\n\n#### general shape of these errors\n\nGenerally these errors always take the same shape for me,\nclang-tidy detects that stdexec is dereferencing an optional \n\n```\nget_scheduler(*__context_)),\n```\n\nwithout checking. \nI\u0027m still unsure why it triggers in some cases but not in others.\n\nThe example log is from bios updater where we have the same NOLINT.\n```\n\u003e\u003e\u003e /usr/bin/clang-tidy --use-color -export-fixes /home/alexander/upstreaming/ci_test_area/phosphor-bmc-code-mgmt/buildjjaognaw/meson-private/clang-tidy-fix/spi_device.cpp.3s8e14pm.yaml -quiet -p /home/alexander/upstreaming/ci_test_area/phosphor-bmc-code-mgmt/buildjjaognaw /home/alexander/upstreaming/ci_test_area/phosphor-bmc-code-mgmt/bios/spi_device.cpp\n184269 warnings generated.\n/usr/local/include/sdbusplus/async/stdexec/../stdexec/__detail/__optional.hpp:123:9: error: Branch condition evaluates to a garbage value [clang-analyzer-core.uninitialized.Branch,-warnings-as-errors]\n  123 |         STDEXEC_ASSERT(__has_value);\n      |         ^\n/usr/local/include/sdbusplus/async/stdexec/../stdexec/__detail/__config.hpp:501:9: note: expanded from macro \u0027STDEXEC_ASSERT\u0027\n  501 |         STDEXEC_ASSERT_FN(_XP);                                                \\\n      |         ^\n/usr/local/include/sdbusplus/async/stdexec/../stdexec/__detail/__config.hpp:505:27: note: expanded from macro \u0027STDEXEC_ASSERT_FN\u0027\n  505 | #define STDEXEC_ASSERT_FN assert\n      |                           ^\n/usr/include/assert.h:103:7: note: expanded from macro \u0027assert\u0027\n  103 |      (static_cast \u003cbool\u003e (expr)                                         \\\n      |       ^\n../bios/spi_device.cpp:94:27: note: Calling \u0027__promise::await_transform\u0027\n   94 |     auto prevPowerstate \u003d co_await HostPower::getState(ctx);\n      |                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/usr/local/include/sdbusplus/async/stdexec/task.hpp:434:44: note: Calling \u0027__optional::operator*\u0027\n  434 |                              get_scheduler(*__context_)),\n      |                                            ^~~~~~~~~~~\n/usr/local/include/sdbusplus/async/stdexec/../stdexec/__detail/__optional.hpp:123:9: note: Branch condition evaluates to a garbage value\n  123 |         STDEXEC_ASSERT(__has_value);\n      |         ^\n/usr/local/include/sdbusplus/async/stdexec/../stdexec/__detail/__config.hpp:501:9: note: expanded from macro \u0027STDEXEC_ASSERT\u0027\n  501 |         STDEXEC_ASSERT_FN(_XP);                                                \\\n      |         ^                 ~~~\n/usr/local/include/sdbusplus/async/stdexec/../stdexec/__detail/__config.hpp:505:27: note: expanded from macro \u0027STDEXEC_ASSERT_FN\u0027\n  505 | #define STDEXEC_ASSERT_FN assert\n      |                           ^\n/usr/include/assert.h:103:7: note: expanded from macro \u0027assert\u0027\n  103 |      (static_cast \u003cbool\u003e (expr)                                         \\\n      |       ^      \n```\n\n#### code block causing the issue\n\nThe code block for reference\n\n```\n  425         template \u003csender _Awaitable\u003e\n  426             requires __scheduler_provider\u003c_Context\u003e\n  427         auto await_transform(_Awaitable\u0026\u0026 __awaitable) noexcept\n  428             -\u003e decltype(auto)\n  429         {\n  430             // TODO: If we have a complete-where-it-starts query then we can\n  431             // optimize this to avoid the reschedule\n  432             return as_awaitable(\n  433                 continues_on(static_cast\u003c_Awaitable\u0026\u0026\u003e(__awaitable),\nA\u003e434                              get_scheduler(*__context_)),\n  435                 *this);\n  436         }\n```\n\n#### upstream workaround\n\nIt looks like in the upstream code they used some workaround to hide this from clang\nhttps://github.com/NVIDIA/stdexec/blob/138e136fa4b93e7e096a4968eaac1b0c94f0d255/include/exec/task.hpp#L390\n```\n\n#ifndef __clang_analyzer__\n        template \u003csender _Awaitable\u003e\n          requires __scheduler_provider\u003c_Context\u003e\n        auto await_transform(_Awaitable\u0026\u0026 __awaitable) noexcept -\u003e decltype(auto) {\n          // TODO: If we have a complete-where-it-starts query then we can optimize\n          // this to avoid the reschedule\n          return stdexec::as_awaitable(\n            continues_on(static_cast\u003c_Awaitable\u0026\u0026\u003e(__awaitable), get_scheduler(*__context_)),\n            *this);\n        }\n\n        template \u003cclass _Scheduler\u003e\n          requires __scheduler_provider\u003c_Context\u003e\n        auto await_transform(__reschedule_coroutine_on::__wrap\u003c_Scheduler\u003e __box) noexcept\n          -\u003e decltype(auto) {\n          if (!std::exchange(__rescheduled_, true)) {\n            // Create a cleanup action that transitions back onto the current scheduler:\n            auto __sched \u003d get_scheduler(*__context_);\n            auto __cleanup_task \u003d at_coroutine_exit(schedule, std::move(__sched));\n            // Insert the cleanup action into the head of the continuation chain by making\n            // direct calls to the cleanup task\u0027s awaiter member functions. See type\n            // _cleanup_task in at_coroutine_exit.hpp:\n            __cleanup_task.await_suspend(__coro::coroutine_handle\u003c__promise\u003e::from_promise(*this));\n            (void) __cleanup_task.await_resume();\n          }\n          __context_-\u003eset_scheduler(__box.__sched_);\n          return stdexec::as_awaitable(schedule(__box.__sched_), *this);\n        }\n#endif\n```\n\nwe can blame to see the commit introducing this guard\n\nhttps://github.com/NVIDIA/stdexec/commit/41f673ee50ce5f3b652522b95a5a35c58cba9eb6\n\nand the relevant PR\n\nhttps://github.com/NVIDIA/stdexec/pull/1551\n\n#### thoughts\n\nIMO the fix looks sus because it hides the actual issue.\n\nIf the code works without the section they compiled out, why not remove it entirely?\n\nIf the code does not work without these functions, then why not put the NOLINT at that location, so library users do not have to deal with it.",
      "parentUuid": "22f8e7b3_910d6edd",
      "revId": "ade5c5aad34fa313b1bdd88577f44ba6f64ef43c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ],
  "submitRequirementResults": []
}