// This file was autogenerated.  Do not edit!
// See elog-gen.py for more details
#pragma once

#include <phosphor-logging/elog.hpp>
#include <phosphor-logging/log.hpp>
#include <sdbusplus/exception.hpp>

#include <string>
#include <tuple>
#include <type_traits>

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace Error
{
struct UnTarFailure;
} // namespace Error
} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace Error
{
struct ManifestFileFailure;
} // namespace Error
} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace Error
{
struct ImageFailure;
} // namespace Error
} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace Error
{
struct InternalFailure;
} // namespace Error
} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace sdbusplus
{
namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace Error
{
struct BusyFailure;
} // namespace Error
} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz
} // namespace sdbusplus

namespace phosphor
{

namespace logging
{

namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace _UnTarFailure
{

struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>, const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)){};
    type _entry;
};

} // namespace _UnTarFailure

struct UnTarFailure
{
    static constexpr auto L = level::ERR;
    using PATH = _UnTarFailure::PATH;
    using metadata_types = std::tuple<PATH>;
};

} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz

namespace details
{

template <>
struct map_exception_type<
    sdbusplus::xyz::openbmc_project::Software::Image::Error::UnTarFailure>
{
    using type = xyz::openbmc_project::Software::Image::UnTarFailure;
};

} // namespace details

namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace _ManifestFileFailure
{

struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>, const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)){};
    type _entry;
};

} // namespace _ManifestFileFailure

struct ManifestFileFailure
{
    static constexpr auto L = level::ERR;
    using PATH = _ManifestFileFailure::PATH;
    using metadata_types = std::tuple<PATH>;
};

} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz

namespace details
{

template <>
struct map_exception_type<sdbusplus::xyz::openbmc_project::Software::Image::
                              Error::ManifestFileFailure>
{
    using type = xyz::openbmc_project::Software::Image::ManifestFileFailure;
};

} // namespace details

namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace _InternalFailure
{

struct FAIL
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "FAIL";
    using type = std::tuple<std::decay_t<decltype("FAIL=%s")>, const char*>;
    explicit constexpr FAIL(const char* a) : _entry(entry("FAIL=%s", a)){};
    type _entry;
};

} // namespace _InternalFailure

struct InternalFailure
{
    static constexpr auto L = level::ERR;
    using FAIL = _InternalFailure::FAIL;
    using metadata_types = std::tuple<FAIL>;
};

} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz

namespace details
{

template <>
struct map_exception_type<
    sdbusplus::xyz::openbmc_project::Software::Image::Error::InternalFailure>
{
    using type = xyz::openbmc_project::Software::Image::InternalFailure;
};

} // namespace details

namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace _ImageFailure
{

struct FAIL
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "FAIL";
    using type = std::tuple<std::decay_t<decltype("FAIL=%s")>, const char*>;
    explicit constexpr FAIL(const char* a) : _entry(entry("FAIL=%s", a)){};
    type _entry;
};

} // namespace _ImageFailure

struct ImageFailure
{
    static constexpr auto L = level::ERR;
    using FAIL = _ImageFailure::FAIL;
    using metadata_types = std::tuple<FAIL>;
};

} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz

namespace details
{

template <>
struct map_exception_type<
    sdbusplus::xyz::openbmc_project::Software::Image::Error::ImageFailure>
{
    using type = xyz::openbmc_project::Software::Image::ImageFailure;
};

} // namespace details

namespace xyz
{
namespace openbmc_project
{
namespace Software
{
namespace Image
{
namespace _BusyFailure
{

struct PATH
{
    /*
     * We can't use -fsanitize=undefined if we declare a
     * 'static constexpr auto str' member, so don't. Instead, open-code the
     * mako template lookups.
     */
    static constexpr auto str_short = "PATH";
    using type = std::tuple<std::decay_t<decltype("PATH=%s")>, const char*>;
    explicit constexpr PATH(const char* a) : _entry(entry("PATH=%s", a)){};
    type _entry;
};

} // namespace _BusyFailure

struct BusyFailure
{
    static constexpr auto L = level::ERR;
    using PATH = _BusyFailure::PATH;
    using metadata_types = std::tuple<PATH>;
};

} // namespace Image
} // namespace Software
} // namespace openbmc_project
} // namespace xyz

namespace details
{

template <>
struct map_exception_type<
    sdbusplus::xyz::openbmc_project::Software::Image::Error::BusyFailure>
{
    using type = xyz::openbmc_project::Software::Image::BusyFailure;
};

} // namespace details

} // namespace logging

} // namespace phosphor
