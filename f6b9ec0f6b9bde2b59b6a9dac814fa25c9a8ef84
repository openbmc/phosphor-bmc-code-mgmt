{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7ff09c5b_fd977179",
        "filename": "common/src/software.cpp",
        "patchSetId": 11
      },
      "lineNbr": 143,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2025-03-12T03:38:07Z",
      "side": 1,
      "message": "Why is this change needed only for version interface? I am trying to understand how other interfaces such as Progress, Activation are working without this change?",
      "revId": "f6b9ec0f6b9bde2b59b6a9dac814fa25c9a8ef84",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e072be28_bf87ad63",
        "filename": "common/src/software.cpp",
        "patchSetId": 11
      },
      "lineNbr": 143,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-03-12T13:52:55Z",
      "side": 1,
      "message": "There are different signals such as\n\n- PropertiesChanged\n- InterfacesAdded\n- InterfacesRemoved\n- ...\n\n## How ObjectMapper uses DBus Signals\n\nFor the use-case of discovering object paths and DBus names which have certain interfaces, the object mapper uses \u0027InterfacesAdded\u0027 and \u0027InterfacesRemoved\u0027 to update its internal data structures.\n\nThis is a link to ObjectMapper main() function:\n\nhttps://github.com/openbmc/phosphor-objmgr/blob/2a1ef0138c33036c82793104287e72d41f778108/src/main.cpp#L466\n\nChanging a property in aserver instance can result in ```PropertiesChanged``` signal.\n\n\n## Why i believe the change is needed\n\nDepending on how an application comes to know about an interface on an object path, it may or may not require those signals.\n\nTo be notified of Progress and Activation state change, i would assume a ```PropertiesChanged``` signal is required. I did not read the bmcweb implementation, but that would make sense to me.\nThe ```PropertiesChanged``` signal should be emitted as a result of \n\n    \n```\nversion-\u003eversion(...);\n```\n\nsince it has a template argument EmitSignal which defaults to true, which you kindly pointed out to me üòä\n\n```\n      template \u003cbool EmitSignal \u003d true, typename Arg \u003d std::string\u003e\n      void version(Arg\u0026\u0026 new_value)\n          requires server_details::has_set_property_nomsg\u003cversion_t, Instance,\n                                                          std::string\u003e\n      {\n          bool changed \u003d static_cast\u003cInstance*\u003e(this)-\u003eset_property(\n              version_t{}, std::forward\u003cArg\u003e(new_value));\n  \n          if (changed \u0026\u0026 EmitSignal)\n          {\n              _xyz_openbmc_project_software_Version_interface.property_changed(\"Version\");\n          }\n      }\n``` \n\nSo from my perspective, since the code is working with respect to Activation and ActivationProgress, we have emitted the required signals for that.\n\nI am not aware if there is any policy which says that every application must always emit ```InterfacesAdded``` for each interface. This seems to be something optional in dbus.\n\n## Looking at the Code for creating async server instance, my perspective\n\nTo emit the ```InterfacesAdded``` signal, it could either happen in the constructor or via some function call. The ObjectManager is documented to have some methods to emit those signals, so i assume they are not always emitted by default.\n\nhttps://dbus.freedesktop.org/doc/dbus-specification.html#basic-types\n\nWhich is confirmed through my experience, that the signals were sometimes not emitted. So it has to be something which needs to be done in the process which is exposing these interfaces.\n\nThe first place to look for ```InterfacesAdded``` would be the constructor:\n\n\n```\nversion \u003d std::make_unique\u003cSoftwareVersion\u003e(ctx, objectPath.str.c_str());\n```\n\n```\n  template \u003ctypename Instance, typename Server \u003d void\u003e\nA\u003estruct Version :\n      public std::conditional_t\u003c\n          std::is_void_v\u003cServer\u003e,\n          sdbusplus::async::server_t\u003cInstance, details::Version\u003e,\n          details::Version\u003cInstance, Server\u003e\u003e\n  {\n      template \u003ctypename... Args\u003e\n      Version(Args\u0026\u0026... args) :\n          std::conditional_t\u003c\n              std::is_void_v\u003cServer\u003e,\n              sdbusplus::async::server_t\u003cInstance, details::Version\u003e,\n              details::Version\u003cInstance, Server\u003e\u003e(std::forward\u003cArgs\u003e(args)...)\n      {}  \n  };\n```\nwith Instance \u003d Software, Server \u003d void.\nThe template should resolve to \n```\nsdbusplus::async::server_t\u003cInstance, details::Version\u003e(std::forward\u003cArgs\u003e(args)...)\n\u003c\u003d\u003e\nsdbusplus::async::server_t\u003cSoftware, details::Version\u003e(ctx, objectPath.str.c_str())\n```\nthen\n```\ntemplate \u003ctypename Instance, template \u003ctypename, typename\u003e typename... Types\u003e\nusing server_t \u003d server::server\u003cInstance, Types...\u003e;\n\u003c\u003d\u003e\nserver::server\u003cSoftware, details::Version\u003e(ctx, objectPath.str.c_str())\n```\n\nwhich then leads to this class\n```\n\n  template \u003ctypename Instance, template \u003ctypename, typename\u003e typename... Types\u003e\nA\u003eclass server :\n      public sdbusplus::async::context_ref,\n      public Types\u003cInstance, server\u003cInstance, Types...\u003e\u003e...\n  { \n    public:\n      using Self \u003d server\u003cInstance, Types...\u003e;\n      friend details::server_context_friend;\n  \n      server() \u003d delete;\n      explicit server(sdbusplus::async::context\u0026 ctx, const char* path) :\n          context_ref(ctx), Types\u003cInstance, Self\u003e(path)...\n      {}\n  };\n```\n\nremembering we passed ```details::Version``` earlier, it will be constructed\n\n```\n\n  template \u003ctypename Instance, typename Server\u003e\nA\u003eclass Version :\n      public sdbusplus::common::xyz::openbmc_project::software::Version,\n      protected server_details::server_context_friend\n  {\n    public:\n      explicit Version(const char* path) :\n          _xyz_openbmc_project_software_Version_interface(\n              _context(), path, interface, _vtable, this)\n      {}\n    \n  \n      /** @brief Emit interface added */\n      void emit_added()\n      {\n          _xyz_openbmc_project_software_Version_interface.emit_added();\n      }\n  \n      /** @brief Emit interface removed */\n      void emit_removed()\n      {\n          _xyz_openbmc_project_software_Version_interface.emit_removed();\n      } \n```\n\nso we are constructing\n```\n\n      sdbusplus::server::interface_t\n          _xyz_openbmc_project_software_Version_interface;\n\nusing interface_t \u003d interface::interface;\n```\n\nwhich then ends up at\n```\n\ninterface::interface(sdbusplus::bus_t\u0026 bus, const char* path,\n                     const char* interf, const sdbusplus::vtable_t* vtable,\n                     void* context) :\n    _bus(get_busp(bus), bus.getInterface()), _path(path), _interf(interf),\n    _interface_added(false),\n    _slot(makeObjVtable(_bus.getInterface(), get_busp(_bus), _path.c_str(),\n                        _interf.c_str(), vtable, context))\n{}\n```\n\nwhere our ```_interface_added``` is initialized as ```false```.\n\n\nAww shoot! So our constructor did probably not initialize the interface....\n\nSince our instance inherits from ```details::Version``` we can just call \n```emit_added()``` to fix that.\n\n```\n\n      /** @brief Emit interface added */\n      void emit_added()\n      { \n          _xyz_openbmc_project_software_Version_interface.emit_added();\n      } \n```\n\nand there we meet the guard again, to prevent us from emitting this signal more than once.\n\n```\n      /** @brief Emit the interface is added on D-Bus */\nA\u003e    void emit_added()\n      {   \n          if (!_interface_added)\n          {   \n              _bus.emit_interfaces_added(_path.c_str(), {_interf});\n              _interface_added \u003d true;\n          }   \n      }   \n```\n\n## Summary\n\nBased on my limited understanding of the code:\n\n- there is a guard in place to prevent us from emitting ```InterfacesAdded``` more than once\n- emit_added() should be safe to call if all properties are initialized\n\ni would recommend to call ```emit_added()``` in those cases where we actually need the signal.\n\nThere is a change currently in review for sdbusplus which proposes some way to pass properties into aserver constructor so that the constructor will be able to call ```emit_added()``` by itself.\n\n\nLet me know if you have a different understanding of the code or believe this signal to be generated elsewhere üëç",
      "parentUuid": "7ff09c5b_fd977179",
      "revId": "f6b9ec0f6b9bde2b59b6a9dac814fa25c9a8ef84",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e64547fc_62b0a1ac",
        "filename": "common/src/software.cpp",
        "patchSetId": 11
      },
      "lineNbr": 143,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2025-03-27T01:53:05Z",
      "side": 1,
      "message": "We can go with this change until the related change is made in sdbusplus. Once sdbusplus change lands please drop this fix.",
      "parentUuid": "e072be28_bf87ad63",
      "revId": "f6b9ec0f6b9bde2b59b6a9dac814fa25c9a8ef84",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}